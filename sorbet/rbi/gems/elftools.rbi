# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/elftools/all/elftools.rbi
#
# elftools-1.1.3

module ELFTools
end
module ELFTools::Constants
  include ELFTools::Constants::DF
  include ELFTools::Constants::DT
  include ELFTools::Constants::EM
  include ELFTools::Constants::ET
  include ELFTools::Constants::PF
  include ELFTools::Constants::PT
  include ELFTools::Constants::SHN
  include ELFTools::Constants::SHT
  include ELFTools::Constants::STB
  include ELFTools::Constants::STT
end
module ELFTools::Constants::DF
end
module ELFTools::Constants::DT
end
module ELFTools::Constants::EM
  def self.mapping(val); end
end
module ELFTools::Constants::ET
  def self.mapping(type); end
end
module ELFTools::Constants::PF
end
module ELFTools::Constants::PT
end
module ELFTools::Constants::SHN
end
module ELFTools::Constants::SHT
end
module ELFTools::Constants::STB
end
module ELFTools::Constants::STT
end
class ELFTools::ELFError < StandardError
end
class ELFTools::ELFMagicError < ELFTools::ELFError
end
class ELFTools::ELFClassError < ELFTools::ELFError
end
class ELFTools::ELFDataError < ELFTools::ELFError
end
class ELFTools::LazyArray
  def [](i); end
  def initialize(size, &block); end
end
module ELFTools::Sections
end
class ELFTools::Sections::Section
  def data; end
  def header; end
  def initialize(header, stream, offset_from_vma: nil, strtab: nil, **_kwargs); end
  def name; end
  def null?; end
  def self.create(header, stream, *args, **kwargs); end
  def stream; end
  def type; end
end
module ELFTools::Dynamic
  def each_tags(&block); end
  def endian; end
  def str_offset; end
  def tag_at(n); end
  def tag_by_type(type); end
  def tags; end
  def tags_by_type(type); end
end
class ELFTools::Dynamic::Tag
  def header; end
  def initialize(header, stream, str_offset); end
  def name; end
  def name?; end
  def stream; end
  def value; end
end
class ELFTools::Sections::DynamicSection < ELFTools::Sections::Section
  def tag_start; end
  include ELFTools::Dynamic
end
module ELFTools::Structs
end
class BinData::Record < BinData::Struct
  def self.inherited(subclass); end
end
class ELFTools::Structs::ELFStruct < BinData::Record
  def elf_class; end
  def elf_class=(arg0); end
  def offset; end
  def offset=(arg0); end
  def patches; end
  def self.inherited(subclass); end
  def self.new(*args); end
  def self.pack(val, bytes); end
  def self.self_endian; end
end
class ELFTools::Structs::ELF_Ehdr < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF_EhdrBe < ELFTools::Structs::ELF_Ehdr
end
class ELFTools::Structs::ELF_EhdrLe < ELFTools::Structs::ELF_Ehdr
end
class BinData::Uint16be < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Uint16le < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Uint32be < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Uint32le < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Uint64be < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Uint64le < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class ELFTools::Structs::ELF_Shdr < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF_ShdrBe < ELFTools::Structs::ELF_Shdr
end
class ELFTools::Structs::ELF_ShdrLe < ELFTools::Structs::ELF_Shdr
end
class ELFTools::Structs::ELF32_Phdr < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF32_PhdrBe < ELFTools::Structs::ELF32_Phdr
end
class ELFTools::Structs::ELF32_PhdrLe < ELFTools::Structs::ELF32_Phdr
end
class ELFTools::Structs::ELF64_Phdr < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF64_PhdrBe < ELFTools::Structs::ELF64_Phdr
end
class ELFTools::Structs::ELF64_PhdrLe < ELFTools::Structs::ELF64_Phdr
end
class ELFTools::Structs::ELF32_sym < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF32_symBe < ELFTools::Structs::ELF32_sym
end
class ELFTools::Structs::ELF32_symLe < ELFTools::Structs::ELF32_sym
end
class ELFTools::Structs::ELF64_sym < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF64_symBe < ELFTools::Structs::ELF64_sym
end
class ELFTools::Structs::ELF64_symLe < ELFTools::Structs::ELF64_sym
end
class ELFTools::Structs::ELF_Nhdr < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF_NhdrBe < ELFTools::Structs::ELF_Nhdr
end
class ELFTools::Structs::ELF_NhdrLe < ELFTools::Structs::ELF_Nhdr
end
class ELFTools::Structs::ELF_Dyn < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF_DynBe < ELFTools::Structs::ELF_Dyn
end
class ELFTools::Structs::ELF_DynLe < ELFTools::Structs::ELF_Dyn
end
class BinData::Int32be < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Int64be < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Int32le < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Int64le < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class ELFTools::Structs::ELF_Rel < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF_RelBe < ELFTools::Structs::ELF_Rel
end
class ELFTools::Structs::ELF_RelLe < ELFTools::Structs::ELF_Rel
end
class ELFTools::Structs::ELF_Rela < ELFTools::Structs::ELFStruct
  def self.inherited(subclass); end
  def self.new(*args); end
end
class ELFTools::Structs::ELF_RelaBe < ELFTools::Structs::ELF_Rela
end
class ELFTools::Structs::ELF_RelaLe < ELFTools::Structs::ELF_Rela
end
module ELFTools::Util
  extend ELFTools::Util::ClassMethods
end
module ELFTools::Util::ClassMethods
  def align(num, bit); end
  def cstring(stream, offset); end
  def select_by_type(enum, type); end
  def to_constant(mod, val); end
end
module ELFTools::Note
  def create_note(cur); end
  def each_notes; end
  def endian; end
  def notes; end
end
class ELFTools::Note::Note
  def desc; end
  def description; end
  def header; end
  def initialize(header, stream, offset); end
  def name; end
  def offset; end
  def stream; end
end
class ELFTools::Sections::NoteSection < ELFTools::Sections::Section
  def note_start; end
  def note_total_size; end
  include ELFTools::Note
end
class ELFTools::Sections::NullSection < ELFTools::Sections::Section
  def null?; end
end
class ELFTools::Sections::RelocationSection < ELFTools::Sections::Section
  def create_relocation(n); end
  def each_relocations(&block); end
  def num_relocations; end
  def rela?; end
  def relocation_at(n); end
  def relocations; end
end
class ELFTools::Relocation
  def header; end
  def initialize(header, stream); end
  def mask_bit; end
  def r_info_sym; end
  def r_info_type; end
  def stream; end
  def symbol_index; end
  def type; end
end
class ELFTools::Sections::StrTabSection < ELFTools::Sections::Section
  def name_at(offset); end
end
class ELFTools::Sections::SymTabSection < ELFTools::Sections::Section
  def create_symbol(n); end
  def each_symbols(&block); end
  def initialize(header, stream, section_at: nil, **_kwargs); end
  def num_symbols; end
  def symbol_at(n); end
  def symbol_by_name(name); end
  def symbols; end
  def symstr; end
end
class ELFTools::Sections::Symbol
  def header; end
  def initialize(header, stream, symstr: nil); end
  def name; end
  def stream; end
end
module ELFTools::Segments
end
class ELFTools::Segments::Segment
  def data; end
  def executable?; end
  def header; end
  def initialize(header, stream, offset_from_vma: nil); end
  def readable?; end
  def self.create(header, stream, *args, **kwargs); end
  def stream; end
  def type; end
  def writable?; end
end
class ELFTools::Segments::DynamicSegment < ELFTools::Segments::Segment
  def tag_start; end
  include ELFTools::Dynamic
end
class ELFTools::Segments::InterpSegment < ELFTools::Segments::Segment
  def interp_name; end
end
class ELFTools::Segments::LoadSegment < ELFTools::Segments::Segment
  def file_head; end
  def file_tail; end
  def mem_head; end
  def mem_size; end
  def mem_tail; end
  def offset_in?(offset, size = nil); end
  def offset_to_vma(offset); end
  def size; end
  def vma_in?(vma, size = nil); end
  def vma_to_offset(vma); end
end
class ELFTools::Segments::NoteSegment < ELFTools::Segments::Segment
  def note_start; end
  def note_total_size; end
  include ELFTools::Note
end
class ELFTools::ELFFile
  def build_id; end
  def create_section(n); end
  def create_segment(n); end
  def each_sections(&block); end
  def each_segments(&block); end
  def elf_class; end
  def elf_type; end
  def endian; end
  def header; end
  def identify; end
  def initialize(stream); end
  def loaded_headers; end
  def machine; end
  def num_sections; end
  def num_segments; end
  def offset_from_vma(vma, size = nil); end
  def patches; end
  def save(filename); end
  def section_at(n); end
  def section_by_name(name); end
  def sections; end
  def sections_by_type(type, &block); end
  def segment_at(n); end
  def segment_by_type(type); end
  def segments; end
  def segments_by_type(type, &block); end
  def stream; end
  def strtab_section; end
end
