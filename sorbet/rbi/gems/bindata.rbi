# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/bindata/all/bindata.rbi
#
# bindata-2.4.10

module BinData
  def self.trace_message; end
  def self.trace_reading(io = nil); end
  def trace_message; end
  def trace_reading(io = nil); end
  extend BinData::BitFieldFactory
  extend BinData::IntFactory
end
class BinData::ValidityError < StandardError
end
module BinData::Framework
  def assign(val); end
  def bit_aligned?; end
  def clear?; end
  def debug_name_of(child); end
  def do_num_bytes; end
  def do_read(io); end
  def do_write(io); end
  def initialize_instance; end
  def initialize_shared_instance; end
  def offset_of(child); end
  def snapshot; end
end
module BinData::IO
  def self.create_string_io(str = nil); end
end
module BinData::IO::Common
  def buffer_limited_n(n); end
  def initialize(io); end
  def seek(n); end
  def seekable?; end
  def with_buffer_common(n); end
end
module BinData::IO::Common::SeekableStream
  def num_bytes_remaining; end
  def offset_raw; end
  def read_raw(n); end
  def seek_raw(n); end
  def stream_init; end
  def with_readahead; end
  def write_raw(data); end
end
module BinData::IO::Common::UnSeekableStream
  def num_bytes_remaining; end
  def offset_raw; end
  def read_raw(n); end
  def read_raw_with_readahead(n); end
  def seek_raw(n); end
  def stream_init; end
  def with_readahead; end
  def write_raw(data); end
end
class BinData::IO::Read
  def accumulate_big_endian_bits; end
  def accumulate_little_endian_bits; end
  def initialize(io); end
  def mask(nbits); end
  def offset; end
  def read(n = nil); end
  def read_all_bytes; end
  def read_big_endian_bits(nbits); end
  def read_little_endian_bits(nbits); end
  def readbits(nbits, endian); end
  def readbytes(n); end
  def reset_read_bits; end
  def seekbytes(n); end
  def with_buffer(n); end
  include BinData::IO::Common
end
class BinData::IO::Write
  def flush; end
  def flushbits; end
  def initialize(io); end
  def mask(nbits); end
  def offset; end
  def seekbytes(n); end
  def with_buffer(n); end
  def write(data); end
  def write_big_endian_bits(val, nbits); end
  def write_little_endian_bits(val, nbits); end
  def writebits(val, nbits, endian); end
  def writebytes(str); end
  include BinData::IO::Common
end
class BinData::LazyEvaluator
  def callable?(obj); end
  def eval_symbol_in_parent_context(symbol, args); end
  def index; end
  def initialize(obj); end
  def lazy_eval(val, overrides = nil); end
  def method_missing(symbol, *args); end
  def parent; end
  def recursively_eval(val, args); end
  def resolve_symbol_in_parent_context(symbol, args); end
end
module BinData::RegisterNamePlugin
  def initialize_shared_instance; end
  def self.included(base); end
end
module BinData::AcceptedParametersPlugin
  def accepted_parameters; end
  def default_parameter(*args); end
  def default_parameters(*args); end
  def mandatory_parameter(*args); end
  def mandatory_parameters(*args); end
  def mutually_exclusive_parameters(*args); end
  def optional_parameter(*args); end
  def optional_parameters(*args); end
end
class BinData::AcceptedParametersPlugin::AcceptedParameters
  def all; end
  def default(args = nil); end
  def ensure_valid_names(names); end
  def initialize(ancestor_parameters = nil); end
  def mandatory(*args); end
  def mutually_exclusive(*args); end
  def optional(*args); end
  def self.invalid_parameter_names; end
  def to_syms(args); end
end
class BinData::UnRegisteredTypeError < StandardError
end
class BinData::Registry
  def initialize; end
  def lookup(name, hints = nil); end
  def name_with_endian(name, endian); end
  def name_with_prefix(name, prefix); end
  def normalize_name(name, hints); end
  def register(name, class_to_register); end
  def register_dynamic_class(name); end
  def registered?(name); end
  def underscore_name(name); end
  def unregister(name); end
  def warn_if_name_is_already_registered(name, class_to_register); end
end
class BinData::SanitizedParameter
end
class BinData::SanitizedPrototype < BinData::SanitizedParameter
  def has_parameter?(param); end
  def initialize(obj_type, obj_params, hints); end
  def instantiate(value = nil, parent = nil); end
end
class BinData::SanitizedField < BinData::SanitizedParameter
  def has_parameter?(param); end
  def initialize(name, field_type, field_params, hints); end
  def instantiate(value = nil, parent = nil); end
  def name; end
  def name_as_sym; end
  def prototype; end
end
class BinData::SanitizedFields < BinData::SanitizedParameter
  def [](idx); end
  def add_field(type, name, params); end
  def all_field_names_blank?; end
  def any_field_has_parameter?(parameter); end
  def each(&block); end
  def empty?; end
  def field_name?(name); end
  def field_names; end
  def initialize(hints, base_fields = nil); end
  def length; end
  def no_field_names_blank?; end
  def raw_fields; end
  include Enumerable
end
class BinData::SanitizedChoices < BinData::SanitizedParameter
  def [](key); end
  def initialize(choices, hints); end
end
class BinData::SanitizedBigEndian < BinData::SanitizedParameter
  def endian; end
end
class BinData::SanitizedLittleEndian < BinData::SanitizedParameter
  def endian; end
end
class BinData::SanitizedParameters < Hash
  def create_sanitized_choices(choices); end
  def create_sanitized_endian(endian); end
  def create_sanitized_fields; end
  def create_sanitized_object_prototype(obj_type, obj_params); end
  def create_sanitized_params(params, the_class); end
  def ensure_mandatory_parameters_exist; end
  def ensure_mutual_exclusion_of_parameters; end
  def ensure_no_nil_values; end
  def has_at_least_one_of?(*keys); end
  def has_parameter?(arg0); end
  def hints; end
  def initialize(parameters, the_class, hints); end
  def merge_default_parameters!; end
  def must_be_integer(*keys); end
  def needs_sanitizing?(key); end
  def rename_parameter(old_key, new_key); end
  def sanitize!; end
  def sanitize(key, &block); end
  def sanitize_choices(key, &block); end
  def sanitize_endian(key); end
  def sanitize_fields(key, &block); end
  def sanitize_object_prototype(key); end
  def self.sanitize(parameters, the_class); end
  def warn_replacement_parameter(bad_key, suggested_key); end
end
class BinData::Base
  def ==(other); end
  def =~(other); end
  def abs_offset; end
  def base_respond_to?(*arg0); end
  def binary_string(str); end
  def clear; end
  def debug_name; end
  def eval_parameter(key, overrides = nil); end
  def extract_args(args); end
  def get_parameter(key); end
  def has_parameter?(key); end
  def initialize(*args); end
  def initialize_instance(*args); end
  def initialize_with_warning(*args); end
  def initialize_without_warning(*args); end
  def inspect; end
  def lazy_evaluator; end
  def new(value = nil, parent = nil); end
  def num_bytes; end
  def parent; end
  def parent=(arg0); end
  def pretty_print(pp); end
  def read(io, &block); end
  def reading?; end
  def rel_offset; end
  def safe_respond_to?(symbol, include_private = nil); end
  def self.arg_processor(name = nil); end
  def self.auto_call_delayed_io; end
  def self.bindata_name; end
  def self.inherited(subclass); end
  def self.read(io, *args, &block); end
  def self.register_subclasses; end
  def self.unregister_self; end
  def start_read; end
  def to_binary_s(&block); end
  def to_hex(&block); end
  def to_s; end
  def top_level; end
  def top_level_get(sym); end
  def top_level_set(sym, value); end
  def write(io, &block); end
  extend BinData::AcceptedParametersPlugin
  include BinData::Framework
  include BinData::RegisterNamePlugin
end
class BinData::BaseArgProcessor
  def extract_args(obj_class, obj_args); end
  def sanitize_parameters!(obj_class, obj_params); end
  def separate_args(_obj_class, obj_args); end
end
module BinData::MultiFieldArgSeparator
  def field_names_in_parameters?(obj_class, parameters); end
  def parameters_is_value?(obj_class, value, parameters); end
  def separate_args(obj_class, obj_args); end
end
module BinData::DSLMixin
  def dsl_parser(parser_type = nil); end
  def method_missing(symbol, *args, &block); end
  def to_ary; end
  def to_str; end
end
class BinData::DSLMixin::DSLParser
  def append_field(type, name, params); end
  def dsl_params; end
  def dsl_raise(exception, msg); end
  def endian(endian = nil); end
  def ensure_hints; end
  def fields; end
  def fields?; end
  def hide(*args); end
  def hints; end
  def initialize(the_class, parser_type); end
  def method_missing(*args, &block); end
  def option?(opt); end
  def parent_attribute(attr, default = nil); end
  def parent_fields; end
  def parse_and_append_field(*args, &block); end
  def parser_abilities; end
  def parser_type; end
  def search_prefix(*args); end
  def set_endian(endian); end
  def to_choice_params(key); end
  def to_object_params(key); end
  def to_struct_params(*unused); end
  def valid_endian?(endian); end
end
class BinData::DSLMixin::DSLBigAndLittleEndianHandler
  def self.class_with_endian(class_name, endian); end
  def self.create_subclasses_with_endian(bnl_class); end
  def self.delegate_field_creation(bnl_class); end
  def self.fixup_subclass_hierarchy(bnl_class); end
  def self.handle(bnl_class); end
  def self.make_class_abstract(bnl_class); end
  def self.obj_attribute(obj, attr); end
  def self.override_new_in_class(bnl_class); end
end
class BinData::DSLMixin::DSLFieldParser
  def initialize(hints, symbol, *args, &block); end
  def name; end
  def name_from_field_declaration(args); end
  def params; end
  def params_from_args(args); end
  def params_from_block(&block); end
  def params_from_field_declaration(args, &block); end
  def type; end
end
class BinData::DSLMixin::DSLFieldValidator
  def all_or_none_names_failed?(name); end
  def duplicate_name?(name); end
  def ensure_valid_name(name); end
  def fields; end
  def initialize(the_class, parser); end
  def malformed_name?(name); end
  def must_have_a_name_failed?(name); end
  def must_not_have_a_name_failed?(name); end
  def name_is_reserved?(name); end
  def name_shadows_method?(name); end
  def option?(opt); end
  def validate_field(name); end
end
class BinData::Array < BinData::Base
  def <<(*args); end
  def [](arg1, arg2 = nil); end
  def []=(index, value); end
  def append_new_element; end
  def assign(array); end
  def at(index); end
  def clear?; end
  def concat(array); end
  def debug_name_of(child); end
  def do_num_bytes; end
  def do_write(io); end
  def each; end
  def elements; end
  def empty?; end
  def extend_array(max_index); end
  def find_index(obj); end
  def find_index_of(obj); end
  def first(n = nil); end
  def index(obj); end
  def initialize_instance; end
  def initialize_shared_instance; end
  def insert(index, *objs); end
  def last(n = nil); end
  def length; end
  def new_element; end
  def offset_of(child); end
  def push(*args); end
  def size; end
  def slice(arg1, arg2 = nil); end
  def slice_index(index); end
  def slice_range(range); end
  def slice_start_length(start, length); end
  def snapshot; end
  def sum_num_bytes_below_index(index); end
  def sum_num_bytes_for_all_elements; end
  def to_ary; end
  def unshift(*args); end
  extend BinData::DSLMixin
  include Enumerable
end
class BinData::ArrayArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
end
module BinData::ReadUntilPlugin
  def do_read(io); end
end
module BinData::ReadUntilEOFPlugin
  def do_read(io); end
end
module BinData::InitialLengthPlugin
  def do_read(io); end
  def elements; end
end
class BinData::BasePrimitive < BinData::Base
  def <=>(other); end
  def _value; end
  def assign(val); end
  def clear?; end
  def do_num_bytes; end
  def do_read(io); end
  def do_read_with_hook(io); end
  def do_write(io); end
  def eql?(other); end
  def hash; end
  def initialize_instance; end
  def initialize_shared_instance; end
  def method_missing(symbol, *args, &block); end
  def read_and_return_value(io); end
  def respond_to?(symbol, include_private = nil); end
  def self.bit_aligned; end
  def self.inherited(subclass); end
  def self.turn_off_tracing; end
  def self.turn_on_tracing; end
  def sensible_default; end
  def snapshot; end
  def trace_value; end
  def value; end
  def value=(val); end
  def value_to_binary_string(val); end
end
module BinData::BasePrimitive::ValuePlugin
  def _value; end
  def assign(val); end
end
module BinData::BasePrimitive::InitialValuePlugin
  def _value; end
end
module BinData::BasePrimitive::AssertPlugin
  def assert!; end
  def assign(val); end
  def do_read(io); end
end
module BinData::BasePrimitive::AssertedValuePlugin
  def _value; end
  def assert!; end
  def assert_value(current_value); end
  def assign(val); end
  def do_read(io); end
end
module BinData::BitField
  def self.create_clamp_code(nbits, signed); end
  def self.create_do_num_bytes_code(nbits); end
  def self.create_dynamic_clamp_code(signed); end
  def self.create_fixed_clamp_code(nbits, signed); end
  def self.create_int2uint_code(nbits, signed); end
  def self.create_nbits_code(nbits); end
  def self.create_params_code(nbits); end
  def self.create_uint2int_code(nbits, signed); end
  def self.define_class(name, nbits, endian, signed = nil); end
  def self.define_methods(bit_class, nbits, endian, signed); end
end
class BinData::Bit < BinData::BasePrimitive
  def assign(val); end
  def bit_aligned?; end
  def do_num_bytes; end
  def do_write(io); end
  def read_and_return_value(io); end
  def sensible_default; end
end
class BinData::BitLe < BinData::BasePrimitive
  def assign(val); end
  def bit_aligned?; end
  def do_num_bytes; end
  def do_write(io); end
  def read_and_return_value(io); end
  def sensible_default; end
end
class BinData::Sbit < BinData::BasePrimitive
  def assign(val); end
  def bit_aligned?; end
  def do_num_bytes; end
  def do_write(io); end
  def read_and_return_value(io); end
  def sensible_default; end
end
class BinData::SbitLe < BinData::BasePrimitive
  def assign(val); end
  def bit_aligned?; end
  def do_num_bytes; end
  def do_write(io); end
  def read_and_return_value(io); end
  def sensible_default; end
end
module BinData::BitFieldFactory
  def const_missing(name); end
end
class BinData::Buffer < BinData::Base
  def assign(val); end
  def clear?; end
  def do_num_bytes; end
  def do_read(io); end
  def do_write(io); end
  def initialize_instance; end
  def method_missing(symbol, *args, &block); end
  def raw_num_bytes; end
  def respond_to?(symbol, include_private = nil); end
  def snapshot; end
  extend BinData::DSLMixin
end
class BinData::BufferArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
  include BinData::MultiFieldArgSeparator
end
class BinData::Choice < BinData::Base
  def assign(*args); end
  def clear?(*args); end
  def current_choice; end
  def do_num_bytes(*args); end
  def do_read(*args); end
  def do_read_with_hook(io); end
  def do_write(*args); end
  def initialize_instance; end
  def initialize_shared_instance; end
  def instantiate_choice(selection); end
  def method_missing(symbol, *args, &block); end
  def respond_to?(symbol, include_private = nil); end
  def selection; end
  def self.turn_off_tracing; end
  def self.turn_on_tracing; end
  def snapshot(*args); end
  def trace_selection; end
  extend BinData::DSLMixin
end
class BinData::ChoiceArgProcessor < BinData::BaseArgProcessor
  def choices_as_hash(choices); end
  def ensure_valid_keys(choices); end
  def key_array_by_index(array); end
  def sanitize_parameters!(obj_class, params); end
end
module BinData::CopyOnChangePlugin
  def copy_previous_value(obj); end
  def current_choice; end
  def get_previous_choice(selection); end
  def remember_current_selection(selection); end
end
class BinData::CountBytesRemaining < BinData::BasePrimitive
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::DelayedIO < BinData::Base
  def abs_offset; end
  def abs_offset=(offset); end
  def assign(val); end
  def clear?; end
  def do_num_bytes; end
  def do_read(io); end
  def do_write(io); end
  def initialize_instance; end
  def method_missing(symbol, *args, &block); end
  def num_bytes; end
  def read_now!; end
  def rel_offset; end
  def respond_to?(symbol, include_private = nil); end
  def snapshot; end
  def write_now!; end
  extend BinData::DSLMixin
end
class BinData::DelayedIoArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
  include BinData::MultiFieldArgSeparator
end
module BinData::Base::AutoCallDelayedIO
  def initialize_shared_instance; end
  def num_bytes; end
  def read(io); end
  def write(io, *_); end
end
module BinData::FloatingPoint
  def self.create_num_bytes_code(precision); end
  def self.create_read_code(precision, endian); end
  def self.create_to_binary_s_code(precision, endian); end
  def self.define_methods(float_class, precision, endian); end
end
class BinData::FloatLe < BinData::BasePrimitive
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::FloatBe < BinData::BasePrimitive
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::DoubleLe < BinData::BasePrimitive
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::DoubleBe < BinData::BasePrimitive
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
module BinData::Int
  def self.bits_per_word(nbits); end
  def self.create_clamp_code(nbits, signed); end
  def self.create_int2uint_code(nbits); end
  def self.create_raw_read_code(nbits, endian, signed); end
  def self.create_read_assemble_code(nbits, endian, signed); end
  def self.create_read_code(nbits, endian, signed); end
  def self.create_read_unpack_code(nbits, endian, signed); end
  def self.create_to_binary_s_code(nbits, endian, signed); end
  def self.create_uint2int_code(nbits); end
  def self.define_class(name, nbits, endian, signed); end
  def self.define_methods(int_class, nbits, endian, signed); end
  def self.need_signed_conversion_code?(nbits, signed); end
  def self.pack_directive(nbits, endian, signed); end
  def self.val_as_packed_words(nbits, endian, signed); end
end
class BinData::Uint8 < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Int8 < BinData::BasePrimitive
  def assign(val); end
  def do_num_bytes; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
module BinData::IntFactory
  def const_missing(name); end
end
class BinData::Struct < BinData::Base
  def [](key); end
  def []=(key, value); end
  def as_stringified_hash(val); end
  def assign(val); end
  def assign_fields(val); end
  def base_field_name(name); end
  def clear; end
  def clear?; end
  def debug_name_of(child); end
  def define_field_accessors; end
  def define_field_accessors_for(name, index); end
  def do_num_bytes; end
  def do_read(io); end
  def do_write(io); end
  def each_pair; end
  def field_names(include_hidden = nil); end
  def find_index_of(obj); end
  def find_obj_for_name(name); end
  def has_key?(key); end
  def include_obj?(obj); end
  def initialize_instance; end
  def initialize_shared_instance; end
  def instantiate_all_objs; end
  def instantiate_obj_at(index); end
  def key?(key); end
  def offset_of(child); end
  def self.inherited(subclass); end
  def snapshot; end
  def sum_num_bytes_below_index(index); end
  def sum_num_bytes_for_all_fields; end
end
class BinData::Struct::Snapshot < Hash
  def []=(key, value); end
  def method_missing(symbol, *args); end
  def respond_to?(symbol, include_private = nil); end
end
module BinData::ByteAlignPlugin
  def align_obj?(obj); end
  def bytes_to_align(obj, rel_offset); end
  def do_read(io); end
  def do_write(io); end
  def sum_num_bytes_below_index(index); end
end
class BinData::StructArgProcessor < BinData::BaseArgProcessor
  def ensure_field_names_are_valid(obj_class, field_names); end
  def hidden_field_names(hidden); end
  def sanitize_endian(params); end
  def sanitize_fields(obj_class, params); end
  def sanitize_hide(params); end
  def sanitize_parameters!(obj_class, params); end
  def sanitize_search_prefix(params); end
  def sanitized_field_names(sanitized_fields); end
end
class BinData::Primitive < BinData::BasePrimitive
  def assign(val); end
  def debug_name_of(child); end
  def do_num_bytes; end
  def do_write(io); end
  def get; end
  def initialize_instance; end
  def method_missing(symbol, *args, &block); end
  def read_and_return_value(io); end
  def respond_to?(symbol, include_private = nil); end
  def self.bit_aligned; end
  def sensible_default; end
  def set(v); end
  extend BinData::DSLMixin
end
class BinData::PrimitiveArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
end
class BinData::Record < BinData::Struct
  extend BinData::DSLMixin
end
class BinData::RecordArgProcessor < BinData::StructArgProcessor
  def sanitize_parameters!(obj_class, params); end
  include BinData::MultiFieldArgSeparator
end
class BinData::Rest < BinData::BasePrimitive
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Skip < BinData::BasePrimitive
  def initialize_shared_instance; end
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::SkipArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
end
module BinData::SkipLengthPlugin
  def skip_length; end
end
module BinData::SkipToAbsOffsetPlugin
  def skip_length; end
end
module BinData::SkipUntilValidPlugin
  def read_and_return_value(io); end
  def skip_length; end
end
class BinData::String < BinData::BasePrimitive
  def assign(val); end
  def clamp_to_length(str); end
  def initialize_shared_instance; end
  def read_and_return_value(io); end
  def sensible_default; end
  def snapshot; end
  def trim_padding(str); end
  def value_to_binary_string(val); end
end
class BinData::StringArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
  def sanitized_pad_byte(byte); end
end
module BinData::WarnNoReadLengthPlugin
  def read_and_return_value(io); end
end
class BinData::Stringz < BinData::BasePrimitive
  def append_zero_byte_if_needed!(str); end
  def assign(val); end
  def read_and_return_value(io); end
  def sensible_default; end
  def snapshot; end
  def trim_and_zero_terminate(str); end
  def trim_to!(str, max_length = nil); end
  def truncate_after_first_zero_byte!(str); end
  def value_to_binary_string(val); end
end
class BinData::Tracer
  def initialize(io); end
  def trace(msg); end
  def trace_obj(obj_name, val); end
end
class BinData::Uint8Array < BinData::BasePrimitive
  def read_and_return_value(io); end
  def sensible_default; end
  def value_to_binary_string(val); end
end
class BinData::Uint8ArrayArgProcessor < BinData::BaseArgProcessor
  def sanitize_parameters!(obj_class, params); end
end
class BinData::Virtual < BinData::BasePrimitive
  def do_num_bytes; end
  def do_read(io); end
  def do_write(io); end
  def sensible_default; end
end
class BinData::ResumeByteAlignment < BinData::Base
  def assign(val); end
  def clear?; end
  def do_num_bytes; end
  def do_read(io); end
  def do_write(io); end
  def snapshot; end
end
module BinData::BitAligned
  def bit_aligned?; end
  def do_num_bytes; end
  def do_write(io); end
  def read_and_return_value(io); end
end
class BinData::BitAligned::BitAlignedIO
  def initialize(io); end
  def readbytes(n); end
end
